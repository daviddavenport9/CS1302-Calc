package cs1302.calc;

/**
* This class implements the MathOps interface using
* recursion to enable each operation
*
* @author David Davenport
*/
public class RecursiveMathOps implements MathOps{

/**
* adds two ints using recursion
*
* @param lhs the left hand side of the operation
* @param rhs the right hand side of the operation
*/
public int add(int lhs, int rhs)
{
 if (rhs == 0) 
 {
 return lhs;
 }//if
 return add(succ(lhs), pred(rhs));
}//add

/**
* subtracts two ints using recursion
*
* @param lhs the left hand side of the operation
* @param rhs the right hand side of the operation
*/
public int sub(int lhs, int rhs)
{
 if (rhs == 0) 
 {
 return lhs;
 }//if
 if (rhs > lhs)
 {
 return 0;
 }
 return sub(pred(lhs), pred(rhs));
}//sub

/**
* multiplies two ints using recursion
*
* @param lhs the left hand side of the operation
* @param rhs the right hand side of the operation
*/
public int mul(int lhs, int rhs)
{
 if (rhs == 1) return lhs;
 if ((rhs ==0) || (lhs == 0)) return 0;
 return add(lhs, mul(lhs, pred(rhs))); 
}//mul

/**
* divides two ints using recursion
*
* @param lhs the left hand side of the operation
* @param rhs the right hand side of the operation
* @throws ArithmeticExpression if rhs is zero
*/
public int div(int lhs, int rhs) throws ArithmeticException
{
  if (rhs == 0)
 {
 throw new ArithmeticException("Can't divide by zero");
 }
 if (lhs < rhs) return 0;
 return succ(div(sub(lhs, rhs), rhs));
}//div

/**
* computes the factorial of a number using recursion
*
* @param num the number to be used for the factorial
*/
public int fac(int num)
{
 int result;
 if(num==0 || num==1)
 {
 return 1;
 }//if
 result = mul(fac(pred(num)), num);
 return result;
}//fac

/**
* computes powers using recursion
*
* @param lhs the left hand side of the operation and the base of the operation
* @param rhs the right hand side of the operation and the exponent of the operation
*/
public int pow(int lhs, int rhs)
{
    if (rhs < 1)
    {
    return 1;
    } //if
    else
    {
    return mul(lhs, pow(lhs, pred(rhs)));
    }//else
}//pow

/**
* left shifts two ints using recursion
*
* @param lhs the left hand side of the operation and number that is shifted
* @param rhs the right hand side of the operation and number of how many shifts
*/
public int lshift(int lhs, int rhs)
{
  if (rhs == 0)
  {
    return lhs;
  }
  return lshift(mul(lhs,2) , pred(rhs));
}//lshift

/**
* right shifts two ints using recursion
*
* @param lhs the left hand side of the operation and number that is shifted
* @param rhs the right hand side of the operation and number of how many shifts
*/
public int rshift(int lhs, int rhs)
{
  if (rhs == 0)
  {
  return lhs;
  }
  return rshift(div(lhs,2), pred(rhs));
}//rshift
 }//class
